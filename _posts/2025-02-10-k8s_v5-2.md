---
layout:     post                    # 使用的布局（不需要改）
title:      k8s权威指南学习-2            # 标题 
subtitle:   kubernetes                     #副标题
date:       2025-02-10             # 时间
author:     wangyang                     # 作者
header-img: img/post-bg-coffee.jpeg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - k8s
---

# Service

### Service定义

通过创建service，可以为一组具有相同功能的容器应用提供一个统一的入口地址，并且将请求负载分发到后端的各个容器应用上。

```
# webapp-deployment.yaml
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp
spec:
  replicas: 2
  selector:
    matchLabels:
      app: webapp
  template:
    metadata:
      labels:
        app: webapp
    spec:
      containers:
      - name: webapp
        image: kubeguide/tomcat-app:v1
        ports:
        - containerPort: 8080


# webapp-service.yaml
---
apiVersion: v1
kind: Service
metadata:
  name: webapp
spec:
  ports:
  - protocol: TCP
    port: 8080          //servcie服务监听端口号
    targetPort: 8080    //后端pod服务容器端口号
  selector:             //匹配相关pod标签
    app: webapp
```

Service实现微服务架构相关核心功能：全自动的服务注册、服务发现、服务负载均衡

命令创建Service:  kubectl expose deployment <deployment_name>

```
service对应后端由pod的IP和容器端口号组成，在k8s系统中叫Endpoint。
kubectl describe service <service_name>      查看service详细信息
kubectl get endpoints             查看endpoints对象
```

Service还可以以DNS域名方式存在，域名表示方法为：

```
<service_name>.<namespace>.svc.<cluster_domain>
service名称.命名空间.svc.k8s集群设置的域名后缀
```

从service服务IP到后端pod的负载均衡由每个node上的kube-proxy负责实现



### Service会话保持机制

```
支持通过设置service.spec.sessionAffinity: ClientIP 实现基于客户端IP的会话保持机制，请求会转发到相同的后端pod上
spec:
  sessionAffinity: ClientIP
  sessionAffinityConfig:
    clientIP:
      timeoutSeconds: xxx      //设置会话保持最长时间
```



### Service的多端口设置

一个容器应用可以提供多个端口的服务，在service定义中也可以相应地设置多个端口号。

或者同一个端口号使用协议不同，也需设置多个端口号来提供不同的服务

```
spec
  ......
  ports:
  - name: dns
    port: 53
    targetPort: 53
    protocol: UDP
  - name: dns-tcp   //设置端口号区分
    port: 53
    targetPort: 53
    protocol: TCP    
```



### 将外部服务定义为service

Service还可以抽象定义任意其他服务，可以将k8s集群外的已知服务定义为k8s内的一个Service，供集群内的其他应用访问，场景：

已部署的集群外服务，数据库、缓存

其他k8s集群的某个服务

针对这种情况，设置Service不需要设置label selector（无后端pod存在），但需要定义Service关联的Endpoint资源对象，设置外部服务IP地址和端口号

```
---
kind: Service
apiVersion: v1
metadata:
  name: my-service
spec:
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80

---
kind: Endpoints    //请求将路由到自定义后端的Endpoint上
apiVersion: v1
metadata:
  name: my-service
subsets:
- addresses:
  - ip: 1.2.3.4
  ports:
  - port: 80
```



### 将Service暴露到集群外部

ClusterIP:仅可被集群内部的客户端应用访问

NodePort:将Service的端口号映射到每个Node的一个端口号上，NodeIP:NodePort

LoadBalancer:将Service映射到一个已存在的负载均衡器的IP地址上，通常在云环境中使用

ExternalName:将Service映射为一个外部域名地址，集群内的客户端应用通过访问这个Service就能访问外部服务了。 内部通过访问 <service_name>.<namespace>.svc.<cluster_domain> 即可访问externalName指定的外部域名

```
---
apiVersion: v1
kind: Service
metadata:
  name: webapp
spec:
  type: NodePort
  ports:
  - port: 8080
    targetPort: 8080
    nodePort: 8081
  selector:
    app: webapp


---
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  type: LoadBalancer
  selector:
    app: MyApp
  ports:
  - protocol: TCP
    port: 80
    targetPort: 9376
  clusterIP: 10.0.171.239


---
apiVersion: v1
kind: Service
metadata:
  name: my-service
  namespace: prod
spec:
  type: ExternalName
  externalName: my.database.example.com
```



### k8s的服务发现机制

指客户端应用在k8s集群中如何获知后端服务的访问地址，环境变量方式和DNS方式获取服务访问地址；

```
环境变量方式：
pod启动时，自动为容器运行环境注入集群中所有有效service信息，包括服务IP、服务端口号、各端口相关协议等

DNS方式：
客户端通过<service_name>.<namespace>.svc.<cluster_domain> DNS域名解析到ClusterIP，
如果端口号设置了名称name，通过_<portname>._<protocol>.<service_name>.<namespace>.svc.<cluster_domain> 获取端口号数值

nslookup -q=srv _<portname>._<protocol>.<service_name>.<namespace>.svc.<cluster_domain>  pod内执行解析
```



### Headless Service的概念和应用

在某些场景，客户端应用不需要通过k8s内置Service完成负载均衡，或者需要自行完成对pod服务后端的服务发现机制，或者需要自行实现负载均衡功能，可以通过创建Headless Service 来实现

Headless Service的概念是服务没有入口访问地址（无ClusterIP:None），kube-proxy不会为其创建负载转发机制，而服务名（DNS域名）的解析机制取决于 该 Headless Service 是否设置了label selector 标签选择器选择后端pod



Headless Service设置了label selector

服务名（DNS域名）的解析机制为：当客户端访问该服务时，得到的是全部Endpoint列表（而不是单独一个地址）

```
apiVersion: v1
kind: Service
metadata:
  name: nginx
  labels:
    app: nginx
spec:
  ports:
  - port: 80
  clusterIP: None
  selector:
    app: nginx
```

```
[root@k8s-master Chapter04]# kubectl describe svc nginx
Name:              nginx
Namespace:         default
Labels:            app=nginx
Annotations:       <none>
Selector:          app=nginx
Type:              ClusterIP
IP Family Policy:  SingleStack
IP Families:       IPv4
IP:                None
IPs:               None
Port:              <unset>  80/TCP
TargetPort:        80/TCP
Endpoints:         10.244.1.87:80,10.244.1.91:80,10.244.2.159:80 + 1 more...
Session Affinity:  None
Events:            <none>
```



Headless Service没有设置label selector

k8s不会创建对应的endpoint列表，如果是外部域名，直接将服务名DNS转为外部域名地址