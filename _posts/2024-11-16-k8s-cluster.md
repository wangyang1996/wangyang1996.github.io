---
layout:     post                    # 使用的布局（不需要改）
title:      k8s集群版二进制安装            # 标题 
subtitle:   k8s                     #副标题
date:       2024-11-16             # 时间
author:     wangyang                     # 作者
header-img: img/post-bg-desk.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - k8s-cluster
---



k8s集群版二进制安装
=================
本篇文章记录k8s集群版二进制安装步骤，使用`k8s+cri-docker+calico+keepalive+nginx`等部署

集群规模 3 master + 1 node 

二进制安装指基础k8s服务kube-apiserver、kube-controller-manager、kube-shecduler、kubelet、kube-proxy等以system.d方式运行，不借助kubeadm初始化方式运行在pod上

Keepalive 对 k8s master节点做主备高可用，1 主 2 备 ，提供VIP用于访问kube-apiserver，防止master节点故障

nginx 监控 VIP 对应端口，该端口映射master节点kube-apiserver端口，对集群kube-apiserver请求做负载均衡

1.基础信息
--------------------------

### 1.1 节点信息


    k8s_master-1    2c2g40G   192.168.230.20    
    k8s-master-2    2c2g40G   192.168.230.21
    k8s-master-3    2c2g40G   192.168.230.22
    k8s-node-1      2c2g40G   192.168.230.23
    VIP + port                192.168.230.230:16443
    Service网段                10.96.0.0/16
    Pod网段                    172.168.0.0/16
    SVC                       10.96.0.1
    DNS                       10.96.0.8
    master节点运行服务：etcd、kube-apiserver、kube-controller-manager、kube-shecduler、kubelet、kube-proxy、keepalive、nginx、docker、containerd、calico
    node节点运行服务：kubelet、kube-proxy、docker、containerd、calico


### 1.2 版本信息

    CentOS: CentOS Linux release 7.9.2009 (Core)
    docker: 23.0.0 API version: 1.42  docker服务端API版本1.42+，支持cri-docker
    cri-docker: cri-dockerd dev (HEAD)
    go: go1.23rc2 linux/amd64
    git: 1.8.3.1
    k8s: v1.30.1
    calico:
    	docker images
    		image: calico/cni:v3.25.0
        image: calico/node:v3.25.0        
        image: calico/kube-controllers:v3.25.0

### 1.3 环境搭建

vmware安装3台虚拟机，终端执行切换命令行模式

    systemctl get-default                    //默认界面
    systemctl set-default multi-user.target  //切命令行界面
    reboot                                   //重启
修改网卡信息：

	BOOTPROTO=static
	IPADDR="192.168.230.xxx"
	NETMASK="255.255.255.0"
	GATEWAY="192.168.230.2"


注意`gateway`地址和虚拟机虚拟网络`VMnet8` NAT设置网关IP一致。如图所示：

<img src="/img/md-img/20240729/1.jpg" width="80%">

windows电脑添加静态路由访问虚拟机

    route -p add 192.168.230.0 mask 255.255.255.0 192.168.230.1
    route print




2.基础信息(全部节点操作)
--------------------------

### 2.1 系统参数配置

所有节点关闭swap和防火墙

    systemctl stop firewalld
    systemctl disable firewalld
    swapoff -a    //临时关闭swapoff 
    sed -ri 's/.*swap.*/#&/' /etc/fstab  //永久关闭swapoff

禁用SELINUX

	setenforce 0
	sed -i 's/enforcing/disabled/' /etc/selinux/config

所有节点设置主机名

    hostnamectl set-hostname  k8s-master-1
    hostnamectl set-hostname  k8s-master-2
    hostnamectl set-hostname  k8s-master-1
    hostnamectl set-hostname  k8s-node-1

所有节点主机名IP加入hosts解析

    vi /etc/hosts
    加入如下内容：
    192.168.230.20 k8s-master-1
    192.168.230.21 k8s-master-2
    192.168.230.22 k8s-master-3
    192.168.230.23 k8s-node-1

所有主机配置主机间免密登陆，每台主机生成公钥分发其他主机

```
eg: k8s-master-1
ssh-keygen                    #一路回车，不输入密码
ssh-copy-id k8s-master-2
ssh-copy-id k8s-master-3
ssh-copy-id k8s-node-1
```

设置内核及相关网络参数

    modprobe  br_netfilter
    modprobe  overlay
    modprobe  ip_vs
    cat <<EOF | sudo tee /etc/modules-load.d/k8s.conf
    overlay
    br_netfilter
    ip_vs
    EOF

------------------

    cat <<EOF | sudo tee /etc/sysctl.d/k8s.conf
    net.bridge.bridge-nf-call-iptables  = 1
    net.bridge.bridge-nf-call-ip6tables = 1
    net.ipv4.ip_forward = 1
    net.ipv4.tcp_tw_recycle=0
    vm.swappiness=0
    vm.overcommit_memory=1
    vm.panic_on_oom=0
    fs.inotify.max_user_instances=8192
    fs.inotify.max_user_watches=1048576
    fs.file-max=52706963
    fs.nr_open=52706963
    net.ipv6.conf.all.disable_ipv6=1
    net.netfilter.nf_conntrack_max=2310720
    EOF
    
    sysctl -p /etc/sysctl.d/k8s.conf

修改DNS

```
vi /etc/resolv.conf
nameserver 223.5.5.5
nameserver 114.114.114.114
```

替换yum源

	##禁用yum加速插件
	vim  /etc/yum/pluginconf.d/fastestmirror.conf
	enabled = 1 改为 0  禁用
	vim /etc/yum.conf
	plugins=0  不使用插件
	yum clean all
	yum clean dbcache
	yum makecache
	
	##替换yum源
	sudo mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup //备份yum源配置
	sudo curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo //下载阿里云源配置文件
	sudo yum clean all     //清理缓存
	sudo yum makecache     //构建yum源

时间同步

    yum install -y yum-utils
    yum install -y ntp ntpdate
    ntpdate cn.pool.ntp.org
    systemctl start ntpd
    systemctl enable ntpd

limit优化

    ulimit -SHn 65535
     
    cat <<EOF >> /etc/security/limits.conf
    soft nofile 655360
    hard nofile 131072
    soft nproc 655350
    hard nproc 655350
    soft memlock unlimited
    hard memlock unlimited
    EOF


### 2.2 Docker安装

配置docker源

    yum install -y yum-utils   
    yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo

安装基础软件包

```
yum install -y yum-utils device-mapper-persistent-data lvm2 wget net-tools nfs-utils lrzsz gcc gcc-c++ make cmake libxml2-devel openssl-devel curl curl-devel unzip sudo ntp libaio-devel wget vim ncurses-devel autoconf automake zlib-devel python-devel epel-release openssh-server socat ipvsadm conntrack ntpdate telnet
```

查看相关docker版本

```
yum provides docker-ce
```

安装docker

    yum remove docker   docker-client   docker-client-latest   docker-common   docker-latest   docker-latest-logrotate   docker-logrotate
    yum install docker-ce-23.0.0-1.el7 docker-ce-cli-23.0.0-1.el7 docker-compose-plugin containerd.io

启动docker

    systemctl start docker
    systemctl enable docker
    docker info 

配置阿里云镜像加速器

    mkdir -p /etc/docker
    cat > /etc/docker/daemon.json << EOF
    {
      "registry-mirrors": ["https://2lfz0oyw.mirror.aliyuncs.com"],
      "exec-opts": ["native.cgroupdriver=systemd"],
      "log-driver": "json-file",
      "log-opts": {
        "max-size": "100m"
      },
      "storage-driver": "overlay2"
    }
    EOF
    sudo systemctl daemon-reload
    sudo systemctl restart docker

### 2.3 cri-docker安装

`kubernetes 1.24+版本之后，docker必须要加装cir-docker`

go安装

    wget https://golang.google.cn/dl/go1.23rc2.linux-amd64.tar.gz
    rm -rf /usr/local/go && tar -C /usr/local/ -xzvf go1.20.12.linux-amd64.tar.gz 

设置环境变量

    vi /etc/profile
    #add setting
    export GOROOT=/usr/local/go
    export GOPATH=/usr/local/gopath
    export PATH=$PATH:$GOROOT/bin
    #保存退出执行
    source /etc/profile

构建cri-dockerd

	git clone https://github.com/Mirantis/cri-dockerd.git

编译

    cd cri-dockerd
    mkdir bin
    go build -o bin/cri-dockerd
    mkdir -p /usr/local/bin
    install -o root -g root -m 0755 bin/cri-dockerd /usr/local/bin/cri-dockerd
    cp -a packaging/systemd/* /etc/systemd/system
    sed -i -e 's,/usr/bin/cri-dockerd,/usr/local/bin/cri-dockerd,' /etc/systemd/system/cri-docker.service

### 2.4 配置cri-docker

编辑：

    vi /etc/systemd/system/cri-docker.service

在`ExecStart`后面追加，如：

    ExecStart=/usr/local/bin/cri-dockerd --container-runtime-endpoint fd:// --network-plugin=cni --pod-infra-container-image=registry.aliyuncs.com/google_containers/pause:3.9

创建cri-docker启动文件

    vi /usr/lib/systemd/system/cri-docker.service
    [Unit]
    Description=CRI Interface for Docker Application Container Engine
    Documentation=https://docs.mirantis.com
    After=network-online.target firewalld.service docker.service
    Wants=network-online.target
    Requires=cri-docker.socket
     
    [Service]
    Type=notify
    ExecStart=/usr/bin/cri-dockerd --network-plugin=cni --pod-infra-container-image=registry.aliyuncs.com/google_containers/pause:3.9
    ExecReload=/bin/kill -s HUP $MAINPID
    TimeoutSec=0
    RestartSec=2
    Restart=always
     
    StartLimitBurst=3
     
    StartLimitInterval=60s
     
    LimitNOFILE=infinity
    LimitNPROC=infinity
    LimitCORE=infinity
     
    TasksMax=infinity
    Delegate=yes
    KillMode=process
     
    [Install]
    WantedBy=multi-user.target

----------------------------------------

    vi /usr/lib/systemd/system/cri-docker.socket
    [Unit]
    Description=CRI Docker Socket for the API
    PartOf=cri-docker.service
     
    [Socket]
    ListenStream=%t/cri-dockerd.sock
    SocketMode=0660
    SocketUser=root
    SocketGroup=docker
     
    [Install]
    WantedBy=sockets.target

启动cri-docker并设置开机自动启动

    systemctl daemon-reload 
    systemctl enable cri-docker --now
    #查看状态
    systemctl is-active cri-docker

### 2.5 节点构建k8s源 （可不配置）

构建k8s源

    cat > /etc/yum.repos.d/kubernetes.repo << EOF
    [kubernetes]
    name=Kubernetes
    baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/
    enabled=1
    gpgcheck=1
    repo_gpgcheck=1
    gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
    EOF
    
    setenforce 0




3.配置CA根证书
--------------------------

### 3.1 下载cfssl

下载cfssl核心组件

    wget https://github.com/cloudflare/cfssl/releases/download/v1.5.0/cfssl_1.5.0_linux_amd64
    wget https://github.com/cloudflare/cfssl/releases/download/v1.5.0/cfssljson_1.5.0_linux_amd64
    wget https://github.com/cloudflare/cfssl/releases/download/v1.5.0/cfssl-certinfo_1.5.0_linux_amd64
    可以浏览器下载重定向后的链接，速度比主机后台下载快

授予执行权限

```
chmod +x cfssl*
```

批量重命名

```
for name in `ls cfssl*`; do mv $name ${name%_1.5.0_linux_amd64};  done
```

移动到文件

```
mv cfssl* /usr/bin
```

### 3.2 ca根配置

```
mkdir -p /etc/kubernetes/pki
cd /etc/kubernetes/pki
```

`vim ca-config.json`               #证书过期时间等基本配置

```
{
    "signing": {
        "default": {
            "expiry": "87600h"
        },
        "profiles": {
            "server": {
                "expiry": "87600h",
                "usages": [
                    "signing",
                    "key encipherment",
                    "server auth"
                ]
            },
            "client": {
                "expiry": "87600h",
                "usages": [
                    "signing",
                    "key encipherment",
                    "client auth"
                ]
            },
            "peer": {
                "expiry": "87600h",
                "usages": [
                    "signing",
                    "key encipherment",
                    "server auth",
                    "client auth"
                ]
            },
            "kubernetes": {
                "expiry": "87600h",
                "usages": [
                    "signing",
                    "key encipherment",
                    "server auth",
                    "client auth"
                ]
            },
            "etcd": {
                "expiry": "87600h",
                "usages": [
                    "signing",
                    "key encipherment",
                    "server auth",
                    "client auth"
                ]
            }
        }
    }
}
```

### 3.3 配置证书签名请求文件

vim /etc/kubernetes/pki/ca-csr.json

```
{
  "CN": "kubernetes",       #公用名,如网站域
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "CN",            #国家
      "ST": "ShangHai",     #省份
      "L": "ShangHai",      #城市
      "O": "Kubernetes",    #组织
      "OU": "Kubernetes"    #单位
    }
  ],
  "ca": {
    "expiry": "87600h"
  }
}
```

### 3.4 生成证书、私钥

```bash
cfssl gencert -initca ca-csr.json | cfssljson -bare ca -
# ca.csr ca.pem(ca公钥) ca-key.pem(ca私钥)
```



## 4.搭建etcd集群

### 4.1 下载etcd

```
master节点安装部署etcd
在master1上执行命令
wget https://github.com/etcd-io/etcd/releases/download/v3.4.16/etcd-v3.4.16-linux-amd64.tar.gz

复制到其他节点
for i in k8s-master-2 k8s-master-3
do 
	scp etcd-* root@$i:/root/
done

所有节点解压到 /usr/local/bin
tar -zxvf etcd-v3.4.16-linux-amd64.tar.gz --strip-components=1 -C /usr/local/bin etcd-v3.4.16-linux-amd64/etcd{,ctl}

验证
etcdctl #只要有打印就没问题
```

### 4.2 生成etcd证书 (k8s-master-1执行)

```
mkdir -p /etc/kubernetes/pki/etcd
cd /etc/kubernetes/pki/etcd
```

vim etcd-ca-csr.json

```
{
  "CN": "etcd",
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "CN",
      "ST": "ShangHai",
      "L": "ShangHai",
      "O": "etcd",
      "OU": "etcd"
    }
  ],
  "ca": {
    "expiry": "87600h"
  }
}
```

生成etcd根ca证书

```
cd /etc/kubernetes/pki/etcd
cfssl gencert -initca etcd-ca-csr.json | cfssljson -bare /etc/kubernetes/pki/etcd/ca -
```

vim etcd-cluster-csr.json

```
{
    "CN": "etcd-cluster",
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "hosts": [  
        "k8s-master-1",         #主机名
        "k8s-master-2",
        "k8s-master-3",
        "192.168.230.20",       #集群节点IP
        "192.168.230.21",
        "192.168.230.22"
    ],
    "names": [
        {
            "C": "CN",
            "ST": "ShangHai",
            "L": "ShangHai",
            "O": "etcd",
            "OU": "etcd"
        }
    ]
}
```

```
使用 cfssl gencert 命令来签发etcd-cluster的etcd证书
cfssl gencert \
   -ca=/etc/kubernetes/pki/etcd/ca.pem \
   -ca-key=/etc/kubernetes/pki/etcd/ca-key.pem \
   -config=/etc/kubernetes/pki/ca-config.json \
   -profile=etcd \
   etcd-cluster-csr.json | cfssljson -bare /etc/kubernetes/pki/etcd/etcd

# 把生成的证书，复制给其他机器
for i in k8s-master-2 k8s-master-3
do 
  ssh $NODE mkdir -p /etc/kubernetes/pki/etcd
	scp -r /etc/kubernetes/pki/etcd root@$i:/etc/kubernetes/pki/etcd
done
```

### 4.3 安装etcd

编写etcd配置文件，在三个master节点上执行

`mkdir -p /etc/etcd`
`vim /etc/etcd/etcd.yaml`

```
name: 'etcd-master1'                #每个节点对应写名称
data-dir: /var/lib/etcd
wal-dir: /var/lib/etcd/wal
snapshot-count: 5000
heartbeat-interval: 100
election-timeout: 1000
quota-backend-bytes: 0
listen-peer-urls: 'https://192.168.230.20:2380'           #节点对应IP，和集群通信
listen-client-urls: 'https://192.168.230.20:2379,http://192.168.230.20:2379'  #节点对应IP
max-snapshots: 3
max-wals: 5
cors:
initial-advertise-peer-urls: 'https://192.168.230.20:2380'   #节点对应IP
advertise-client-urls: 'https://192.168.230.20:2379'         #节点对应IP
discovery:
discovery-fallback: 'proxy'
discovery-proxy:
discovery-srv:
initial-cluster: 'etcd-master1=https://192.168.230.20:2380,etcd-master2=https://192.168.230.21:2380,etcd-master3=https://192.168.230.22:2380'  #集群全部IP
initial-cluster-token: 'etcd-k8s-cluster'
initial-cluster-state: 'new'
strict-reconfig-check: false
enable-v2: true
enable-pprof: true
proxy: 'off'
proxy-failure-wait: 5000
proxy-refresh-interval: 30000
proxy-dial-timeout: 1000
proxy-write-timeout: 5000
proxy-read-timeout: 0
client-transport-security:
  cert-file: '/etc/kubernetes/pki/etcd/etcd.pem'
  key-file: '/etc/kubernetes/pki/etcd/etcd-key.pem'
  client-cert-auth: true
  trusted-ca-file: '/etc/kubernetes/pki/etcd/ca.pem'
  auto-tls: true
peer-transport-security:
  cert-file: '/etc/kubernetes/pki/etcd/etcd.pem'
  key-file: '/etc/kubernetes/pki/etcd/etcd-key.pem'
  peer-client-cert-auth: true
  trusted-ca-file: '/etc/kubernetes/pki/etcd/ca.pem'
  auto-tls: true
debug: false
log-package-levels:
log-outputs: [default]
force-new-cluster: false
```

配置开机自启
`vim /usr/lib/systemd/system/etcd.service`

```
[Unit]
Description=Etcd Service
Documentation=https://etcd.io/docs/v3.4/op-guide/clustering/
After=network.target

[Service]
Type=notify
ExecStart=/usr/local/bin/etcd --config-file=/etc/etcd/etcd.yaml
Restart=on-failure
RestartSec=10
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
Alias=etcd3.service
```

开机启动

```bash
systemctl daemon-reload
systemctl enable --now etcd
```

### 4.4 测试etcd

```
etcdctl --endpoints="192.168.230.20:2379,192.168.230.21:2379,192.168.230.22:2379" --cacert=/etc/kubernetes/pki/etcd/ca.pem --cert=/etc/kubernetes/pki/etcd/etcd.pem --key=/etc/kubernetes/pki/etcd/etcd-key.pem  endpoint status --write-out=table
```

+---------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+
|      ENDPOINT       |        ID        | VERSION | DB SIZE | IS LEADER | IS LEARNER | RAFT TERM | RAFT INDEX | RAFT APPLIED INDEX | ERRORS |
+---------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+
| 192.168.230.20:2379 | 4d9b38820452e6d2 |  3.4.16 |   10 MB |      true |      false |      2953 |     558378 |             558378 |        |
| 192.168.230.21:2379 | 158fa595ca6cdb5d |  3.4.16 |   10 MB |     false |      false |      2953 |     558378 |             558378 |        |
| 192.168.230.22:2379 | 1ed1f6577708c052 |  3.4.16 |   10 MB |     false |      false |      2953 |     558378 |             558378 |        |
+---------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+



## 5.keepalive + nginx 搭建

在三台master节点分别安装keepalived+nginx，实现对apiserver的负载均衡和反向代理。

```
yum -y install epel-release nginx keepalived nginx-mod-stream 
```

### nginx安装

所有master节点修改配置nginx.conf配置文件

`vim /etc/nginx/nginx.conf`

```
user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log;
pid /run/nginx.pid;

include /usr/share/nginx/modules/*.conf;

events {
    worker_connections  1024;
}

stream {
    log_format  main  '$remote_addr $upstream_addr - [$time_local] $status $upstream_bytes_sent';
    access_log  /var/log/nginx/k8s-access.log  main;

    upstream k8s-apiserver {                               #master主机
        server 192.168.230.20:6443 weight=5 max_fails=3 fail_timeout=30s;  
        server 192.168.230.21:6443 weight=5 max_fails=3 fail_timeout=30s;
        server 192.168.230.22:6443 weight=5 max_fails=3 fail_timeout=30s;
    }

    server {
        listen 16443;                                      #监听端口，避免与默认端口6443冲突
        proxy_pass k8s-apiserver;  
    }
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    include /etc/nginx/conf.d/*.conf;
}
```

重启nginx并设置开机自启

```
systemctl restart nginx && systemctl enable nginx
```

### 监控nginx脚本

脚本监控nginx运行状态，nginx故障尝试重启nginx，启动失败则stop keepalived剔除节点

所有master节点执行

`vim /etc/keepalived/keepalived_nginx_check.sh`

```
#!/bin/bash

# 定义日志文件路径
LOG_FILE="/var/log/nginx_keepalived_check.log"
MAX_LINES=1000  # 设置日志保留1000行（因为不做限制日志会无限增大，占用大量磁盘空间）

# 记录日志的函数，带有详细的时间格式，并保留最后1000行日志
log_message() {
    local time_stamp=$(date '+%Y-%m-%d %H:%M:%S')  # 定义时间格式
    echo "$time_stamp - $1" >> $LOG_FILE
    
    # 截取日志文件，只保留最后1000行
    tail -n $MAX_LINES $LOG_FILE > ${LOG_FILE}.tmp && mv ${LOG_FILE}.tmp $LOG_FILE
}

# 检测 Nginx 是否在运行的函数
check_nginx() {
    pgrep -f "nginx: master" > /dev/null 2>&1
    echo $?
}

# 1. 检查 Nginx 是否存活
log_message "正在检查 Nginx 状态..."
if [ $(check_nginx) -ne 0 ]; then
    log_message "Nginx 未运行，尝试启动 Nginx..."

    # 2. 如果 Nginx 不在运行，则尝试启动
    systemctl start nginx
    sleep 2  # 等待 Nginx 启动

    # 3. 再次检查 Nginx 状态
    log_message "启动 Nginx 后再次检查状态..."
    if [ $(check_nginx) -ne 0 ]; then
        log_message "Nginx 启动失败，停止 Keepalived 服务..."
        
        # 4. 如果 Nginx 启动失败，停止 Keepalived
        systemctl stop keepalived
    else
        log_message "Nginx 启动成功。"
    fi
else
    log_message "Nginx 正常运行。"
fi
```

赋权

```
chmod +x /etc/keepalived/keepalived_nginx_check.sh
```

### keepalived安装

#### k8s-master-1:

`vim /etc/keepalived/keepalived.conf`

```
global_defs {
   router_id LVS_DEVEL
}

vrrp_script keepalived_nginx_check {  
    script "/etc/keepalived/keepalived_nginx_check.sh"   #检测脚本
}  

vrrp_instance VI_1 {
    state MASTER                  #对应修改
    interface ens33               #网卡
    mcast_src_ip 192.168.230.20   #本机IP
    virtual_router_id 51   
    priority 100                  #优先级
    advert_int 1         
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
        192.168.230.230           #VIP
    }
    track_script {
        keepalived_nginx_check 
    }
}
```

#### k8s-master-2:

`vim /etc/keepalived/keepalived.conf`

```
global_defs {
   router_id LVS_DEVEL
}

vrrp_script keepalived_nginx_check {  
    script "/etc/keepalived/keepalived_nginx_check.sh"  
}  

vrrp_instance VI_1 {
    state BACKUP                 
    interface ens33   
    mcast_src_ip 192.168.230.21 
    virtual_router_id 51   
    priority 90         
    advert_int 1         
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
        192.168.230.230 
    }
    track_script {
        keepalived_nginx_check 
    }
}
```

#### k8s-master-3:

`vim /etc/keepalived/keepalived.conf`

```
global_defs {
   router_id LVS_DEVEL
}

vrrp_script keepalived_nginx_check {  
    script "/etc/keepalived/keepalived_nginx_check.sh"  
}  

vrrp_instance VI_1 {
    state BACKUP                 
    interface ens33   
    mcast_src_ip 192.168.230.22 
    virtual_router_id 51   
    priority 80       
    advert_int 1         
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
        192.168.230.230 
    }
    track_script {
        keepalived_nginx_check 
    }
}
```

### 重载配置文件并重启nginx+keepalived服务

```
systemctl daemon-reload && systemctl restart nginx 
systemctl restart keepalived && systemctl enable keepalived
```

检查VIP是否绑定

```
ip address show | grep 192.168.230.230
```



## 6.安装k8s组件和配置各组件证书

### 6.1 下载安装k8s

```
wget https://dl.k8s.io/v1.30.1/kubernetes-server-linux-amd64.tar.gz
可以浏览器下载重定向后的链接，速度比主机后台下载快
```

```
将kubernetes安装包把复制给所有节点
for i in  k8s-master-2 k8s-master-3 k8s-node-1
do 
	scp kubernetes-server-linux-amd64.tar.gz root@$i:/root/
done

所有master节点解压kubelet，kubectl等组件到 /usr/local/bin。
tar -xvf kubernetes-server-linux-amd64.tar.gz  --strip-components=3 -C /usr/local/bin kubernetes/server/bin/kube{let,ctl,-apiserver,-controller-manager,-scheduler,-proxy}

所有node节点只需要 /usr/local/bin/kubelet、kube-proxy
tar -xvf kubernetes-server-linux-amd64.tar.gz  --strip-components=3 -C /usr/local/bin kubernetes/server/bin/kube{let,-proxy}
```

### 6.2 生成kube-apiserver 证书

```
cd /etc/kubernetes/pki
```

`vim apiserver-csr.json`

```
{
    "CN": "kube-apiserver",
    "hosts": [                          #允许访问apiserver的IP
      "10.96.0.1",                      #service svc 网段，自定义
      "127.0.0.1",                      #本机IP
      "192.168.230.230",                #集群apiserver VIP，负载均衡
      "192.168.230.20",                 #各主机IP
      "192.168.230.21",
      "192.168.230.22",
      "192.168.230.23",
      "kubernetes",
      "kubernetes.default",
      "kubernetes.default.svc",
      "kubernetes.default.svc.cluster",
      "kubernetes.default.svc.cluster.local"
    ],
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "names": [
        {
            "C": "CN",
            "ST": "ShangHai",
            "L": "ShangHai",
            "O": "Kubernetes",
            "OU": "Kubernetes"
        }
    ]
}
```

生成API服务器证书命令：

```
cfssl gencert   -ca=/etc/kubernetes/pki/ca.pem   -ca-key=/etc/kubernetes/pki/ca-key.pem   -config=/etc/kubernetes/pki/ca-config.json   -profile=kubernetes   apiserver-csr.json | cfssljson -bare /etc/kubernetes/pki/apiserver
```

### 6.3 生成front-proxy根ca证书 和 front-proxy-client 证书

`vim /etc/kubernetes/pki/front-proxy-ca-csr.json`

```
{
  "CN": "kubernetes",
  "key": {
     "algo": "rsa",
     "size": 2048
  }
}
```

生成front-proxy根ca命令

```
cfssl gencert   -initca front-proxy-ca-csr.json | cfssljson -bare /etc/kubernetes/pki/front-proxy-ca
```



根据front-proxy根ca证书生成front-proxy-client证书
`vim /etc/kubernetes/pki/front-proxy-client-csr.json`

```json
{
  "CN": "front-proxy-client",
  "key": {
     "algo": "rsa",
     "size": 2048
  }
}
```

生成front-proxy-client 证书

```
cfssl gencert   -ca=/etc/kubernetes/pki/front-proxy-ca.pem   -ca-key=/etc/kubernetes/pki/front-proxy-ca-key.pem   -config=ca-config.json   -profile=kubernetes   front-proxy-client-csr.json | cfssljson -bare /etc/kubernetes/pki/front-proxy-client
```

警告忽略

### 6.4 生成kube-controller-manage证书

`vim /etc/kubernetes/pki/controller-manager-csr.json`

```
{
  "CN": "system:kube-controller-manager",
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "CN",
      "ST": "ShangHai",
      "L": "ShangHai",
      "O": "system:kube-controller-manager",
      "OU": "Kubernetes"
    }
  ]
}
```

生成证书

```javascript
cfssl gencert \
   -ca=/etc/kubernetes/pki/ca.pem \
   -ca-key=/etc/kubernetes/pki/ca-key.pem \
   -config=ca-config.json \
   -profile=kubernetes \
  controller-manager-csr.json | cfssljson -bare /etc/kubernetes/pki/controller-manager
```

生成配置

```json
# set-cluster：设置一个集群项
kubectl config set-cluster kubernetes \
     --certificate-authority=/etc/kubernetes/pki/ca.pem \
     --embed-certs=true \
     --server=https://192.168.230.230:16443 \
     --kubeconfig=/etc/kubernetes/controller-manager.conf

# set-context 设置一个环境项，一个上下文
kubectl config set-context system:kube-controller-manager@kubernetes \
    --cluster=kubernetes \
    --user=system:kube-controller-manager \
    --kubeconfig=/etc/kubernetes/controller-manager.conf

# set-credentials 设置一个用户项
kubectl config set-credentials system:kube-controller-manager \
     --client-certificate=/etc/kubernetes/pki/controller-manager.pem \
     --client-key=/etc/kubernetes/pki/controller-manager-key.pem \
     --embed-certs=true \
     --kubeconfig=/etc/kubernetes/controller-manager.conf

# use-context 使用某个环境当做默认环境
kubectl config use-context system:kube-controller-manager@kubernetes \
     --kubeconfig=/etc/kubernetes/controller-manager.conf
```

### 6.5 生成scheduler证书

`vim /etc/kubernetes/pki/scheduler-csr.json`

```json
{
  "CN": "system:kube-scheduler",
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "CN",
      "ST": "ShangHai",
      "L": "ShangHai",
      "O": "system:kube-scheduler",
      "OU": "Kubernetes"
    }
  ]
}
```

生成证书

```javascript
cfssl gencert \
   -ca=/etc/kubernetes/pki/ca.pem \
   -ca-key=/etc/kubernetes/pki/ca-key.pem \
   -config=/etc/kubernetes/pki/ca-config.json \
   -profile=kubernetes \
   scheduler-csr.json | cfssljson -bare /etc/kubernetes/pki/scheduler
```

生成配置

```sql
kubectl config set-cluster kubernetes \
     --certificate-authority=/etc/kubernetes/pki/ca.pem \
     --embed-certs=true \
     --server=https://192.168.230.230:16443 \
     --kubeconfig=/etc/kubernetes/scheduler.conf
     
kubectl config set-credentials system:kube-scheduler \
     --client-certificate=/etc/kubernetes/pki/scheduler.pem \
     --client-key=/etc/kubernetes/pki/scheduler-key.pem \
     --embed-certs=true \
     --kubeconfig=/etc/kubernetes/scheduler.conf

kubectl config set-context system:kube-scheduler@kubernetes \
     --cluster=kubernetes \
     --user=system:kube-scheduler \
     --kubeconfig=/etc/kubernetes/scheduler.conf
     
kubectl config use-context system:kube-scheduler@kubernetes \
     --kubeconfig=/etc/kubernetes/scheduler.conf
```

### 6.6 生成admin证书

`vim /etc/kubernetes/pki/admin-csr.json`

```json
{
  "CN": "admin",
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "CN",
      "ST": "ShangHai",
      "L": "ShangHai",
      "O": "system:masters",
      "OU": "Kubernetes"
    }
  ]
}
```

生成证书

```javascript
cfssl gencert \
   -ca=/etc/kubernetes/pki/ca.pem \
   -ca-key=/etc/kubernetes/pki/ca-key.pem \
   -config=/etc/kubernetes/pki/ca-config.json \
   -profile=kubernetes \
   admin-csr.json | cfssljson -bare /etc/kubernetes/pki/admin
```

生成配置

```typescript
kubectl config set-cluster kubernetes \
--certificate-authority=/etc/kubernetes/pki/ca.pem \
--embed-certs=true \
--server=https://192.168.230.230:16443 \
--kubeconfig=/etc/kubernetes/admin.conf

kubectl config set-credentials kubernetes-admin \
--client-certificate=/etc/kubernetes/pki/admin.pem \
--client-key=/etc/kubernetes/pki/admin-key.pem \
--embed-certs=true \
--kubeconfig=/etc/kubernetes/admin.conf

kubectl config set-context kubernetes-admin@kubernetes \
--cluster=kubernetes \
--user=kubernetes-admin \
--kubeconfig=/etc/kubernetes/admin.conf

kubectl config use-context kubernetes-admin@kubernetes \
--kubeconfig=/etc/kubernetes/admin.conf
```

### 6.7 生成ServiceAccount Key

每创建一个ServiceAccount，都会分配一个Secret

而Secret里面有秘钥，秘钥是由sa生成的，所以需要提前创建出sa信息。

```bash
openssl genrsa -out /etc/kubernetes/pki/sa.key 2048
openssl rsa -in /etc/kubernetes/pki/sa.key -pubout -out /etc/kubernetes/pki/sa.pub
```

### 6.8 发送相关配置、证书到其他master节点

在k8s-master-1上执行：

```
for NODE in k8s-master-2 k8s-master-3
do
	scp -r /etc/kubernetes/* root@$NODE:/etc/kubernetes/
done
```



## 7.启动master节点组件

### 7.1 所有的master节点上执行

```bash
mkdir -p /etc/kubernetes/manifests/ /etc/systemd/system/kubelet.service.d /var/lib/kubelet /var/log/kubernetes
```

三个master节点kube-xx相关的程序都在 /usr/local/bin

### 7.2 配置apiserver服务

#### 所有master节点创建kube-apiserver.service

master节点执行
`vim /usr/lib/systemd/system/kube-apiserver.service`

```
[Unit]
Description=Kubernetes API Server
Documentation=https://github.com/kubernetes/kubernetes
After=network.target

[Service]
ExecStart=/usr/local/bin/kube-apiserver \
      --v=2  \
      --allow-privileged=true  \
      --bind-address=0.0.0.0  \
      --secure-port=6443  \
      --advertise-address=192.168.230.20 \                 #本机IP
      --service-cluster-ip-range=10.96.0.0/16  \           #service网段
      --service-node-port-range=30000-32767  \
      --etcd-servers=https://192.168.230.20:2379,https://192.168.230.21:2379,https://192.168.230.22:2379 \                                                          #集群信息
      --etcd-cafile=/etc/kubernetes/pki/etcd/ca.pem  \
      --etcd-certfile=/etc/kubernetes/pki/etcd/etcd.pem  \
      --etcd-keyfile=/etc/kubernetes/pki/etcd/etcd-key.pem  \
      --client-ca-file=/etc/kubernetes/pki/ca.pem  \
      --tls-cert-file=/etc/kubernetes/pki/apiserver.pem  \
      --tls-private-key-file=/etc/kubernetes/pki/apiserver-key.pem  \
      --kubelet-client-certificate=/etc/kubernetes/pki/apiserver.pem  \
      --kubelet-client-key=/etc/kubernetes/pki/apiserver-key.pem  \
      --service-account-key-file=/etc/kubernetes/pki/sa.pub  \
      --service-account-signing-key-file=/etc/kubernetes/pki/sa.key  \
      --service-account-issuer=https://kubernetes.default.svc.cluster.local \
      --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname  \
      --enable-admission-plugins=NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,ResourceQuota  \
      --authorization-mode=Node,RBAC  \
      --enable-bootstrap-token-auth=true  \
      --requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.pem  \
      --proxy-client-cert-file=/etc/kubernetes/pki/front-proxy-client.pem  \
      --proxy-client-key-file=/etc/kubernetes/pki/front-proxy-client-key.pem  \
      --requestheader-allowed-names=aggregator,front-proxy-client  \
      --requestheader-group-headers=X-Remote-Group  \
      --requestheader-extra-headers-prefix=X-Remote-Extra-  \
      --requestheader-username-headers=X-Remote-User

Restart=on-failure
RestartSec=10s
LimitNOFILE=65535

[Install]
WantedBy=multi-user.target
```

#### 启动apiserver

启动命令：`systemctl daemon-reload && systemctl enable --now kube-apiserver`

查看状态命令：`systemctl status kube-apiserver`

检查日志：`journalctl -u kube-apiserver -f`

### 7.3 配置controller-manager服务

#### 所有master节点配置kube-controller-manager.service

master节点执行:
`vim /usr/lib/systemd/system/kube-controller-manager.service`

```
[Unit]
Description=Kubernetes Controller Manager
Documentation=https://github.com/kubernetes/kubernetes
After=network.target

[Service]
ExecStart=/usr/local/bin/kube-controller-manager \
      --v=2 \
      --root-ca-file=/etc/kubernetes/pki/ca.pem \
      --cluster-signing-cert-file=/etc/kubernetes/pki/ca.pem \
      --cluster-signing-key-file=/etc/kubernetes/pki/ca-key.pem \
      --service-account-private-key-file=/etc/kubernetes/pki/sa.key \
      --kubeconfig=/etc/kubernetes/controller-manager.conf \
      --leader-elect=true \
      --use-service-account-credentials=true \
      --node-monitor-grace-period=40s \
      --node-monitor-period=5s \
      --controllers=*,bootstrapsigner,tokencleaner \
      --allocate-node-cidrs=true \
      --cluster-cidr=172.168.0.0/16 \                     #pod网段，可自定义
      --requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.pem \
      --node-cidr-mask-size=24
      
Restart=always
RestartSec=10s

[Install]
WantedBy=multi-user.target
```

#### 启动controller-manager

启动命令：`systemctl daemon-reload && systemctl enable --now kube-controller-manager`

查看状态命令：`systemctl status kube-controller-manager`

检查日志：`journalctl -u kube-controller-manager -f`

### 7.4 配置scheduler服务

#### 所有master节点配置kube-scheduler.service

master节点执行

`vim /usr/lib/systemd/system/kube-scheduler.service`

```
[Unit]
Description=Kubernetes Scheduler
Documentation=https://github.com/kubernetes/kubernetes
After=network.target

[Service]
ExecStart=/usr/local/bin/kube-scheduler \
      --v=2 \
      --leader-elect=true \
      --kubeconfig=/etc/kubernetes/scheduler.conf

Restart=always
RestartSec=10s

[Install]
WantedBy=multi-user.target
```

#### 启动controller-scheduler

启动命令：`systemctl daemon-reload && systemctl enable --now kube-scheduler`

查看状态命令：`systemctl status kube-scheduler`

检查日志：`journalctl -u kube-scheduler -f`



## 8.启动node节点组件

### 8.1 k8s-master-1设置kubectl执行权限

```bash
#只在master1生成，只让一台机器具有操作集群的权限，便于控制
mkdir -p /root/.kube ;
cp /etc/kubernetes/admin.conf /root/.kube/config
#验证
kubectl get nodes 
提示
No resources found
#无报错说明已经可以连接apiserver vip并获取资源
```

### 8.2 k8s-master-1节点将核心证书发送给其他节点

```bash
cd /etc/kubernetes/ 
#执行复制所有令牌操作
for NODE in k8s-master-2 k8s-master-3 k8s-node-1
do
     ssh $NODE mkdir -p /etc/kubernetes/pki/etcd
     for FILE in ca.pem etcd.pem etcd-key.pem; do
       scp /etc/kubernetes/pki/etcd/$FILE $NODE:/etc/kubernetes/pki/etcd/
     done
     for FILE in pki/ca.pem pki/ca-key.pem pki/front-proxy-ca.pem; do
       scp /etc/kubernetes/$FILE $NODE:/etc/kubernetes/${FILE}
     done
done
```

### 8.3 所有节点配置kubelet

```bash
# 所有节点创建相关目录
mkdir -p /var/lib/kubelet /var/log/kubernetes /etc/systemd/system/kubelet.service.d /etc/kubernetes/manifests/

## 所有node节点必须有 kubelet kube-proxy
for NODE in k8s-master-2 k8s-master-3 k8s-node-1; do
    scp -r /etc/kubernetes/* root@$NODE:/etc/kubernetes/
done
```

#### 创建kubelet.service

所有节点配置kubelet服务
`vim /usr/lib/systemd/system/kubelet.service`

```
[Unit]
Description=Kubernetes Kubelet
Documentation=https://github.com/kubernetes/kubernetes
After=docker.service
Requires=docker.service

[Service]
ExecStart=/usr/local/bin/kubelet

Restart=always
StartLimitInterval=0
RestartSec=10

[Install]
WantedBy=multi-user.target
```

所有节点配置kubelet service配置文件

`vim /etc/systemd/system/kubelet.service.d/10-kubelet.conf`

```
[Service]
Environment="KUBELET_KUBECONFIG_ARGS=--kubeconfig=/etc/kubernetes/kubelet.conf"
Environment="KUBELET_CONFIG_ARGS=--config=/etc/kubernetes/kubelet-conf.yml --pod-infra-container-image=registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/pause:3.4.1"
Environment="KUBELET_EXTRA_ARGS=--node-labels=node.kubernetes.io/node='' --container-runtime-endpoint=unix:///var/run/cri-dockerd.sock "
ExecStart=
ExecStart=/usr/local/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS  $KUBELET_EXTRA_ARGS
```

所有节点创建kubelet.conf文件

`vim /etc/kubernetes/kubelet.conf`

```
apiVersion: v1
kind: Config
clusters:
- cluster:
    certificate-authority: /etc/kubernetes/pki/ca.pem
    server: https://192.168.230.230:16443                     #apiserver VIP 地址
  name: default
contexts:
- context:
    cluster: default
    user: kubelet
  name: default
current-context: default
users:
- name: kubelet
  user:
    client-certificate: /var/lib/kubelet/pki/kubelet.pem       #访问apiserver的客户端证书
    client-key: /var/lib/kubelet/pki/kubelet-key.pem           #每个节点对应生成证书
```

所有节点创建kubelet-conf.yml文件

`vim /etc/kubernetes/kubelet-conf.yml`

```
apiVersion: kubelet.config.k8s.io/v1beta1
kind: KubeletConfiguration
address: 0.0.0.0
port: 10250
readOnlyPort: 10255
authentication:
  anonymous:
    enabled: false
  webhook:
    cacheTTL: 2m0s
    enabled: true
  x509:
    clientCAFile: /etc/kubernetes/pki/ca.pem
authorization:
  mode: Webhook
  webhook:
    cacheAuthorizedTTL: 5m0s
    cacheUnauthorizedTTL: 30s
cgroupDriver: systemd
cgroupsPerQOS: true
clusterDNS:
- 10.96.0.8                       #clusterDNS默认是Service网段的第10个IP，可自定义
clusterDomain: cluster.local
containerLogMaxFiles: 5
containerLogMaxSize: 10Mi
contentType: application/vnd.kubernetes.protobuf
cpuCFSQuota: true
cpuManagerPolicy: none
cpuManagerReconcilePeriod: 10s
enableControllerAttachDetach: true
enableDebuggingHandlers: true
enforceNodeAllocatable:
- pods
eventBurst: 10
eventRecordQPS: 5
evictionHard:
  imagefs.available: 15%
  memory.available: 100Mi
  nodefs.available: 10%
  nodefs.inodesFree: 5%
evictionPressureTransitionPeriod: 5m0s
failSwapOn: true
fileCheckFrequency: 20s
hairpinMode: promiscuous-bridge
healthzBindAddress: 127.0.0.1
healthzPort: 10248
httpCheckFrequency: 20s
imageGCHighThresholdPercent: 85
imageGCLowThresholdPercent: 80
imageMinimumGCAge: 2m0s
iptablesDropBit: 15
iptablesMasqueradeBit: 14
kubeAPIBurst: 10
kubeAPIQPS: 5
makeIPTablesUtilChains: true
maxOpenFiles: 1000000
maxPods: 110
nodeStatusUpdateFrequency: 10s
oomScoreAdj: -999
podPidsLimit: -1
registryBurst: 10
registryPullQPS: 5
resolvConf: /etc/resolv.conf
rotateCertificates: true
runtimeRequestTimeout: 2m0s
serializeImagePulls: true
staticPodPath: /etc/kubernetes/manifests
streamingConnectionIdleTimeout: 4h0m0s
syncFrequency: 1m0s
volumeStatsAggPeriod: 1m0s
```

#### 为所有节点kubelet生成访问apiserver的客户端证书（不使用TLS引导）

```
client-certificate: /var/lib/kubelet/pki/kubelet.pem       
client-key: /var/lib/kubelet/pki/kubelet-key.pem
```

 `该集群不使用 TLS 引导，需要为每个节点手动配置了证书和kubelet.conf文件，可以直接使用这些文件启动kubelet`

延伸：

```
1、TLS 引导的作用：
	自动获取证书：kubelet可以通过 TLS 引导自动从 API 服务器获取客户端证书，从而避免手动配置每个节点的证书。
	简化部署：使得节点加入集群的过程更加自动化和简便。
2、bootstrap-kubelet.conf 文件：
	这个文件是一个 Kubernetes 配置文件，通常包含一个 bootstrap 用户的凭据，用于 kubelet 与 API 服务器进行通信。
3、配置 kubelet 使用 bootstrap-kubelet.conf：
  在 kubelet 启动参数 KUBELET_KUBECONFIG_ARGS 中指定 --bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf
```

生成kubelet证书用于访问apiserver

`vi /etc/kubernetes/pki/kubelet-csr.json`

```
{
  "CN": "system:node:k8s-master-1",  #对应节点修改hostname，k8s-master-1生成对应证书分发对应节点
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "CN",
      "ST": "ShangHai",
      "L": "ShangHai",
      "O": "system:nodes",
      "OU": "Kubernetes The Hard Way"
    }
  ]
}
```

生成证书

```
cfssl gencert -ca=/etc/kubernetes/pki/ca.pem -ca-key=/etc/kubernetes/pki/ca-key.pem -config=ca-config.json -profile=kubernetes kubelet-csr.json | cfssljson -bare kubelet
```

每个节点按上述步骤生成对应证书后分发证书

```
scp kubelet.pem  root@对应hostname:/var/lib/kubelet/pki/
scp kubelet-key.pem  root@对应hostname:/var/lib/kubelet/pki/
```

#### 启动kubelet

启动命令：`systemctl daemon-reload && systemctl enable --now kubelet`

查看状态命令：`systemctl status kubelet`

检查日志：`journalctl -u kubelet -f`

### 8.4 所有节点配置kube-proxy

#### 生成kube-proxy.conf

创建kube-proxy的sa

```
kubectl -n kube-system create serviceaccount kube-proxy
```

创建 token、secret

```
kubectl -n kube-system create secret generic kube-proxy-token --from-literal=token=$(kubectl -n kube-system create token kube-proxy --duration=87600h)
```

serviceaccount kube-proxy 绑定 secret kube-proxy-token

```
kubectl edit serviceaccount kube-proxy -n kube-system
```

```
apiVersion: v1
kind: ServiceAccount
metadata:
  creationTimestamp: "2024-11-15T07:11:47Z"
  name: kube-proxy
  namespace: kube-system
  resourceVersion: "201603"
  uid: c9b478a5-a080-48a4-b2d4-c30b27641517
secrets:
- name: kube-proxy-token
```

创建角色绑定 clusterrolebinding

```
kubectl create clusterrolebinding system:kube-proxy \
--clusterrole system:node-proxier \
--serviceaccount kube-system:kube-proxy
```

导出变量，方便后面使用

```
SECRET=$(kubectl -n kube-system get sa/kube-proxy --output=jsonpath='{.secrets[0].name}')
JWT_TOKEN=$(kubectl -n kube-system get secret/$SECRET --output=jsonpath='{.data.token}' | base64 -d)
PKI_DIR=/etc/kubernetes/pki
K8S_DIR=/etc/kubernetes
```

生成kube-proxy配置

```
kubectl config set-cluster kubernetes \
--certificate-authority=/etc/kubernetes/pki/ca.pem \
--embed-certs=true \
--server=https://192.168.230.230:16443 \                     #apiserver地址
--kubeconfig=/etc/kubernetes/kube-proxy.conf
```

生成kube-proxy秘钥设置

```
kubectl config set-credentials kubernetes \
--token=${JWT_TOKEN} \
--kubeconfig=/etc/kubernetes/kube-proxy.conf

kubectl config set-context kubernetes \
--cluster=kubernetes \
--user=kubernetes \
--kubeconfig=/etc/kubernetes/kube-proxy.conf

kubectl config use-context kubernetes \
--kubeconfig=/etc/kubernetes/kube-proxy.conf
```

生成的 kube-proxy.conf 传给每个节点

```
for NODE in k8s-master-2 k8s-master-3 k8s-node-1; do
   scp /etc/kubernetes/kube-proxy.conf $NODE:/etc/kubernetes/kube-proxy.conf
done
```

#### 配置kube-proxy.service

所有节点配置 kube-proxy.service 服务，设置开机自启
`vim /usr/lib/systemd/system/kube-proxy.service`

```yaml
[Unit]
Description=Kubernetes Kube Proxy
Documentation=https://github.com/kubernetes/kubernetes
After=network.target

[Service]
ExecStart=/usr/local/bin/kube-proxy \
  --config=/etc/kubernetes/kube-proxy.yaml \
  --v=2

Restart=always
RestartSec=10s

[Install]
WantedBy=multi-user.target
```

#### 配置kube-proxy.yaml

所有节点配置

`vim /etc/kubernetes/kube-proxy.yaml`

```
apiVersion: kubeproxy.config.k8s.io/v1alpha1
bindAddress: 0.0.0.0
clientConnection:
  acceptContentTypes: ""
  burst: 10
  contentType: application/vnd.kubernetes.protobuf
  kubeconfig: /etc/kubernetes/kube-proxy.conf     #kube-proxy文件
  qps: 5
clusterCIDR: 172.168.0.0/16              #Pod网段
configSyncPeriod: 15m0s
conntrack:
  max: null
  maxPerCore: 32768
  min: 131072
  tcpCloseWaitTimeout: 1h0m0s
  tcpEstablishedTimeout: 24h0m0s
enableProfiling: false
healthzBindAddress: 0.0.0.0:10256
hostnameOverride: ""
iptables:
  masqueradeAll: false
  masqueradeBit: 14
  minSyncPeriod: 0s
  syncPeriod: 30s
ipvs:
  masqueradeAll: true
  minSyncPeriod: 5s
  scheduler: "rr"
  syncPeriod: 30s
kind: KubeProxyConfiguration
metricsBindAddress: 127.0.0.1:10249
mode: "ipvs"
nodePortAddresses: null
oomScoreAdj: -999
portRange: ""
udpIdleTimeout: 250ms
```

#### 启动kube-proxy

启动命令：`systemctl daemon-reload && systemctl enable --now kube-proxy`

查看状态命令：`systemctl status kube-proxy`

检查日志：`journalctl -u kube-proxy -f`



## 9.部署calico

下载calico.yaml

```
wget https://calico-v3-25.netlify.app/archive/v3.25/manifests/calico-etcd.yaml
```

修改镜像名

```
image: calico/cni:v3.25.0
image: calico/node:v3.25.0
image: calico/kube-controllers:v3.25.0
```

修改pod网段

```
- name: CALICO_IPV4POOL_CIDR
  value: "172.168.0.0/16"
```

创建calico

```
kubectl apply -f  calico-etcd.yaml
```

部署过程中如果有相关报错，查看日志处理

```
kubectl get pods -n kube-system
kubectl describe pod <pod_name> -n kube-system
kubectl logs <pod_name> -c <container_name> -n kube-system

kubectl delete -f  calico-etcd.yaml
kubectl delete pod <pod_name> --force
```



## 10.部署DNS

```
git clone https://github.com/coredns/deployment.git
cd deployment/kubernetes

./deploy.sh -s -i 10.96.0.8 | kubectl apply -f -
```



## 验证测试

```
[root@k8s-master-1 ～]# kubectl get pods --all-namespaces
NAMESPACE     NAME                                       READY   STATUS    RESTARTS      AGE
kube-system   calico-kube-controllers-54c87cd46c-7zpdz   1/1     Running   2 (25h ago)   25h
kube-system   calico-node-4jhv5                          1/1     Running   1 (25h ago)   25h
kube-system   calico-node-kxg4l                          1/1     Running   2 (25h ago)   25h
kube-system   calico-node-mbj9b                          1/1     Running   1 (25h ago)   25h
kube-system   calico-node-nzdtr                          1/1     Running   1 (25h ago)   25h
kube-system   coredns-57cb8856f7-kkbvs                   1/1     Running   2 (25h ago)   40h
```

