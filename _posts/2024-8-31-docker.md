---
layout:     post                    # 使用的布局（不需要改）
title:      docker 基础学习            # 标题 
subtitle:   docker                     #副标题
date:       2024-08-31             # 时间
author:     wangyang                     # 作者
header-img: img/post-bg-coffee.jpeg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - docker
---


Docker学习
=================
本篇文章记录docker基础内容学习，命令和组件等

1.docker安装
--------------------------

```
sudo yum remove
sudo yum install -y yum-utils
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo                    //添加源
sudo yum makecache fast    //更新缓存

sudo yum -y install docker-ce      //安装docker
sudo systemctl start docker        //启动docker
docker version

vi daemon.json                     //修改docker仓库信息
[root@xxxxxxxxx ~]# cat /etc/docker/daemon.json 
{
	"registry-mirrors": ["https://xxxxxx.mirror.aliyuncs.com"]
}

sudo systemctl daemon-reload       //重启
sudo systemctl restart docker      //重启docker
docker version
docker info                        //查看docker具体信息
```

## 2.docker基本命令

```
docker pull 镜像名                   //拉取镜像
docker ps -a                        //查看所有容器
docker ps                           //查看运行的容器
docker run -d  --name 容器名  镜像名  //启动容器
docker stop 容器ID                   //停止容器
docker start 容器ID                  //启动容器
docker start $(docker ps -a -q)     //启动全部容器
docker rm 容器ID                     //删除容器
docker rm $(docker ps -a -q)        //删除所有容器
docker builder prune                //清除缓存

docker exec -it 容器名 bash          
//进入容器内部,默认容器内linux包为最小安装，只拥有最基本的命令
Exit 退出容器

docker  cp  容器名：容器路径  宿主机路径
docker  cp  宿主机路径  容器名：容器路径

docker logs 容器名/ID                 //查看日志
docker logs -f --tail=10             //容器名/ID
-f 查看实时日志
-t 查看日志产生日期
```

## 3.docker镜像

```
docker pull                        //拉取镜像
docker pull -a                     //拉取指定仓库全部镜像
docker image ls                    //展示镜像
docker image ls --filter dangling=true   //过滤悬虚镜像
docker image prune                 //移除虚悬镜像
docker image prune -a              //移除没有被使用的镜像
docker image ls --filter reference="*:latest"   //显示标签为latest，并且仓库无层级
docker image ls --format "\{\{\.Size\}\}"  //只返回镜像大小属性
docker search name                 //搜索镜像名称
docker search name --filter "is-official=true"  //搜索镜像名称,只返回官方镜像
docker image inspect 镜像名         //查看镜像分层信息
docker image ls --digests          //显示镜像摘要
docker image pull 镜像名@摘要信息    //根据摘要再次拉取镜像
docker image rm                    //删除镜像
docker rm $(docker ps -a -q)   -f     //删除所有容器，直接发送SIGKILL信号删除
docker image rm $(docker images -q)   //删除全部镜像
```

## 4.docker容器

```
docker run -d  --name 容器名  -p host_port:container_port 镜像名  //启动容器，docker主机端口映射到容器内
docker stop 容器ID                   //停止容器，向容器PID为1的进程发送SIGTERM信号
docker start 容器ID                  //启动容器
docker rm 容器ID                     //删除容器，向容器PID为1的进程发送SIGKILL信号

hypervisor: 硬件虚拟化，将硬件物理资源划分为虚拟资源
容器：操作系统虚拟化，将系统资源划分为虚拟资源

service docker status
systemctl is-active docker

docker run -it 镜像名：版本  命令/应用  //-it使容器具有交互性，exit退出容器终止
容器如果不运行任何进程则无法存在
按下ctrl + P + Q 组合键退出容器但并不会终止容器运行

docker exec -it 容器  命令（bash）
//新建bash进程连接到容器，容器里有两个进程(启动方式是-it方式启动的，两个bash进程
//以后台模式-d启动的是应用主进程)，exit退出当前bash，容器不会终止

容器重启策略：
always:除非明确docker stop 停止容器，都会尝试重启处于停止状态的容器；处于stopped状态的容器，docker-daemon重启的时候会被重启；
docker run --name 容器名  -it --restart always 镜像名  命令
unless-stopped:指定重启策略为unless-stopped并处于stopped状态的容器，不会在docker-daemon重启的时候被重启，这是和always策略的最大区别；
on-failure:在退出容器并且返回值不是0的时候，重启容器。处于stopped状态的容器，docker-daemon重启的时候会被重启；

docker image inspect 镜像      //可以看到容器启动时默认运行的应用列表，Cmd配置项
docker container inspect 容器名  //可以看到容器配置细节和运行时信息
```

## 5.应用的容器化

Dockerfile

```yaml
FROM python:3.9-alpine                  //基础镜像
ADD . /code                             //当前目录全部文件复制到新镜像，新增一层镜像层
WORKDIR /code                           //设置工作目录，下面程序对应目录执行
RUN pip install -i https://pypi.tuna.tsinghua.edu.cn/simple -r requirements.txt    //在镜像执行命令，会创建新的镜像层
CMD ["python", "app.py"]                //默认镜像构建容器后的主程序
```

```
docker image build -t 镜像:版本  .     //根据当前目录Dockerfile文件构建镜像
--nocache=true     //参数表示强制忽略镜像层对缓存的使用
--squash           //合并镜像层
-f                 //指定Dockerfile路径和名称

FROM  指定要构建的镜像的基础镜像
RUN  用于在镜像执行命令，会创建新的镜像层，每个RUN创建一个新镜像层
COPY 用于将文件作为一个新的层添加到镜像中，通常将应用代码复制到镜像中
EXPOSE 记录应用使用的网络端口，即容器端口
ENTRYPOINT 指定镜像以容器方式启动后默认运行的程序

部分指令会在镜像中创建新的镜像层，其他指令只会增加或修改镜像的元数据信息
指令的作用如果是向镜像中增添新的文件或者程序，那么这条指令会新建镜像层。比如：FROM、RUN、COPY、ADD
指令如果只是告诉docker如何完成构建或者如何运行程序，那么只会增加、修改镜像元数据。比如：EXPOSE、WORKDIR、ENV、ENTERPOINT

COPY --from 仅复制生产环境相关的应用代码，不复制不需要的构件，用于多阶段构建，构建精简的生产环境镜像

docker image history  镜像：tag            //构建镜像过程执行指令，顺序自下而上
docker image inspect  镜像：tag            //查看镜像层等基本信息

推送镜像：
docker login            //登陆仓库，docker ID 
docker image tag current-tag new-tag       
//为指定镜像添加额外标签，不需要覆盖已存在的标签，new-tag标签指定新的Repository镜像仓库地址
docker image ls         //多一个docker ID 镜像仓库标签
docker image push new-tag      //推送镜像到仓库

```

私有仓库搭建：

```
docker pull registry:2                       //搭建registry私有仓库
docker run -d -v /opt/registry:/var/lib/registry -p 5000:5000 --name myregistry registry:2
//运行在主机，端口5000，镜像存储路径：/opt/registry
docker tag nginx:latest localhost:5000/nginx:latest   //给镜像打标签
docker push localhost:5000/nginx:latest               //推送镜像到私有仓库
docker pull xx.xx.xx.xx:5000/nginx:latest             //从私有仓库拉取配置

cd /opt/registry/docker/registry/v2/repositories/
http://121.40.199.54:5000/v2/_catalog

在/etc/docker/daemon.json配置私有仓库
"insecure-registries" : ["http://xx.xx.xx.xx:5000"]
```

## 6.Docker Compose

Docker compose安装

```
curl -L "https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose
ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose
docker-compose --version
```

docker-compose.yml

```
4个一级key
version:版本
services:定义不同的应用服务，docker
networks:用于指引docker创建新的网络
volumes:用于指引Docker来创建新的卷
```

```yaml
version: "3.5"
services:
  web-fe:
    build: .                    //根据当前目录下的Dockerfile文件构建镜像
    command: python app.py
    ports:
      - target: 5000
        published: 6000
    networks:
      - counter-net
    volumes:
      - type: volume
        source: counter-vol
        target: /code
  redis:
    image: "redis:alpine"        //定义镜像版本，直接pull
    networks:
      counter-net:

networks:                        //定义docker网络，可根据名称直接互通
  counter-net:

volumes:                         //卷
  counter-vol:
```

```
export PIP_DEFAULT_TIMEOUT=100       //设置超时时间
docker builder prune                 //清除缓存

docker-compose -f xxx.yml  up -d     //构建所需镜像，创建网络和卷，并启动容器
-f 指定文件，不设置默认读取docker-compose.yml或者docker-compose.yaml
-d 后台启动应用

问题：修改dockerfile同级的文件生成镜像，里面文件内容没有改变，
原因：卷里counter-vol的内容没有对应修改，相当于部署好后主机目录是在卷的位置，修改项目下的文件不会同步更新
docker-compose会首先创建卷和网络，应用的代码是位于docker卷中的。
解决方案：
1、docker volume rm 名称 ，删除卷，重新生成
2、/var/lib/docker/volumes/目录名_卷名/_data 里的内容同步修改
3、重新换目录，即换项目
对位于Docker主机上的卷中内容修改会立即作用到容器内的卷里
docker volume inspect 卷名          //查看卷在Docker主机位置

docker-compose 	如果使用 bulid: .参数根据目录下的Dockerfile构建镜像,会将项目名称（目录）和Compose文件定义的资源名称（services）连起来作为新构建镜像名称

docker network ls           //展示网络
docker volume ls            //展示卷
docker exec -it counter-app-web-fe-1  /bin/sh    //进入容器

docker-compose down                //停止、删除应用容器、网络，不会删除卷和镜像
docker-compose ps                  //查看应用状态
docker-compose top                 //各个容器内运行的进程
docker-compose stop                //停止应用，不会删除资源
docker-compose rm                  //删除已停止的应用
docker-compose restart             //重启应用

```

## 7.Docker Swarm

安全集群、编排引擎

安全集群：Swarm将一个或者多个docker节点组织起来，使得用户能够以集群方式管理它们

编排引擎：Swarm提供一套丰富API使得易于部署和管理复杂微服务应用

Swarm的最小调度单元是服务

初始化第一个管理节点 > 加入额外管理节点 > 加入工作节点

单引擎模式切换到swarm集群模式：docker swarm init

切换到swarm模式，并创建新的swarm，将自身设置为第一个管理节点

```
1、登陆到管理节点1并初始化新的Swarm
docker swarm init --advertise-addr 192.168.230.128:2377 --listen-addr 192.168.230.128:2377 
--Swarm initialized: current node (wpdekwcn6pt48044dcs7hwccl) is now a manager.
--advertise-addr 指定其他节点用来连接当前管理节点的IP和端口
--listen-addr 指定用于承载Swarm流量的IP和端口

2、管理节点1列出Swarm中的节点
docker node ls
ID                            HOSTNAME     STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION
wpdekwcn6pt48044dcs7hwccl *   k8s-master   Ready     Active         Leader           26.1.4


3、管理节点1执行docker swarm join-token获取添加工作节点、管理节点命令和token
docker swarm join-token worker
To add a worker to this swarm, run the following command:

docker swarm join --token SWMTKN-1-38xyemi2vxgpke3sfujmebioyq9ekitxdz0vr80r7qo5h66p5m-0kg9j65u2kadgc4lhdixfifjq 192.168.230.128:2377
#################################
docker swarm join-token manager
To add a manager to this swarm, run the following command:

docker swarm join --token SWMTKN-1-38xyemi2vxgpke3sfujmebioyq9ekitxdz0vr80r7qo5h66p5m-55pr3hpj3mxdckrqhvkmwstli 192.168.230.128:2377


4、全部工作节点加入Swarm，工作节点执行
docker swarm join --token SWMTKN-1-38xyemi2vxgpke3sfujmebioyq9ekitxdz0vr80r7qo5h66p5m-0kg9j65u2kadgc4lhdixfifjq 192.168.230.128:2377 --advertise-addr 192.168.230.12*:2377 --listen-addr 192.168.230.12*:2377

5、全部管理节点加入Swarm，管理节点执行
docker swarm join --token SWMTKN-1-38xyemi2vxgpke3sfujmebioyq9ekitxdz0vr80r7qo5h66p5m-55pr3hpj3mxdckrqhvkmwstli 192.168.230.128:2377 --advertise-addr 192.168.230.12*:2377 --listen-addr 192.168.230.12*:2377

6、管理节点1列出Swarm中的节点，*表示执行docker node ls 命令的节点
docker node ls
ID                            HOSTNAME         STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION
73fbjffnm9kb7qwkosfe5w8ys     docker-manager   Ready     Active         Reachable        26.1.4
wpdekwcn6pt48044dcs7hwccl *   k8s-master       Ready     Active         Leader           26.1.4
prv9eiatoqqh1tn9o7a4lc757     k8s-node1        Ready     Active                          26.1.4
ezs4amb456r29i4hlwdy1jurt     k8s-node2        Ready     Active                          26.1.4
```

主节点Leader是唯一一个会对Swarm发送控制命令的节点，只有主节点才会变更配置，或发送任务到工作节点，备用管理节点接收到命令会转发到主节点

最佳实践：

1、部署奇数个管理节点，防止脑裂情况，占大多数管理节点的分区继续管理集群

2、不要部署太多管理节点，3或5个最佳

```
为保证管理节点重新安全加入集群，管理节点使用解锁码方式重新接入
管理节点执行：
docker swarm update --autolock=true     //保存解锁码

Swarm updated.
To unlock a swarm manager after it restarts, run the `docker swarm unlock`
command and provide the following key:

    SWMKEY-1-MaYBnC+qfkZjWpYclgrKIQWPqnAJyKGEjvhx5K/66ek

service docker restart                  //重启管理节点
docker node ls                          //提示被锁
Error response from daemon: Swarm is encrypted and needs to be unlocked before it can be used. Please use "docker swarm unlock" to unlock it.

docker swarm unlock                     //输入解锁码重新接入集群
```

```
docker service create       //创建一个新服务，管理节点和工作节点分配到都会拉取镜像
副本模式：尽可能将副本均匀分布到整个集群
全局模式：每个节点仅运行一个副本，docker service create  加 --mode global 参数部署
docker service create --name web -p 8080:8080 --replicas 3 nigelpoulton/pluralsight-docker-ci

docker service ls           //运行服务
docker service ps 服务名称   //查看服务副本列表和状态
docker service inspect --pretty 服务名称     //查看服务详细信息
docker service scale 服务名称=num            //扩缩容
docker service rm 服务名称                   //删除服务
```

```
实现滚动升级

前提：创建覆盖网络 overlay
docker network create -d overlay uber-net
覆盖网络是一个二层网络，容器接入该网络可以实现容器互通
Docker主机通过底层网络相连，中间经过三层交换机相连
容器则通过覆盖网络相连

docker network ls    //查看网络
docker service create --name uber-svc --network uber-net -p 80:80 --replicas 6 nigelpoulton/tu-demo:v1
入站模式，Swarm所有节点开放80端口，无论是否有副本
所有节点配置有映射，请求没有运行副本的IP也会转发到其他节点副本

docker service create --name uber-svc --network uber-net --publish published=80,target=80,mode=host --replicas 6 nigelpoulton/tu-demo:v1
主机模式，仅在运行副本的节点开放80端口

docker service update --image nigelpoulton/tu-demo:v2 --update-parallelism 2 --update-delay 20s uber-svc
滚动更新服务镜像，每次更新两个副本，更新间隔为20s
watch -n 2 -d 'docker service ps uber-svc'
观察滚动更新结果
docker service inspect --pretty uber-svc 
更新并行和时延已成为定义的一部分，待下次docker service update覆盖

docker service logs  service_name     //查看日志
--follow  跟踪日志
--tail 显示最近日志
--details 获取额外细节
```

